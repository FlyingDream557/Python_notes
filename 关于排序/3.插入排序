# -*- coding: utf-8 -*-

# 插入排序和冒泡排序的过程及区别如下
# 插入排序，是从第二个元素开始，一次判断前面元素，然后插入正确位置，直到最后一个
# 冒泡排序，是两两相比，直到最后，确定最后一个，然后倒数第二个，依次类推

# 最大的不同，就是移动的方式不同


# 插入排序方法1
def insert_sort(arr):
    # 此为插入排序, 将当前的一直和前面的比较，直到不能移动。
    # (从第二个元素开始，一次和前面元素进行排序，也就是将第二个元素后面的元素，都插入到前面排序的序列中)
    for i in range(1, len(arr)):
        for j in range(i, 0, -1):
            if arr[j - 1] > arr[j]:
                arr[j - 1], arr[j ] = arr[j], arr[j - 1]
            # else 可以没有，但是可以减少一些没必要的比较
            else:  # 可以减少一些不必要的比较。  # 此为从后向前，找位置插入(与图演示相符)
                break
        print(arr)

    return arr

# 插入排序方法2
def insertion_sort(arr):
    # 获得从第二个开始的元素
    for i in range(1, len(arr)):
        for j in range(i):  # 得到 当前索引i 元素前的元素。 如果前面元素大，则交换，继续比较
            if arr[j] > arr[i]:
                arr[i], arr[j] = arr[j], arr[i]
            # else:  # 如果前面元素大， 则交换，否则不交换，直接退出。
            #     break
            # else 可以没有，但是可以减少一些没必要的比较
            else:  # 此为从前向后找位置插入
                break

        print(arr)

    return arr

# 冒泡排序
def bubble_sort(arr):
    # 此为冒泡排序， 两两比较，交换位置，一直循环两两比较
    for i in range(1, len(arr)):
        for j in range(len(arr) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        print(arr)

    return arr



a=[1,2,3,4,5,1,6,0]
a=[2,4,5,1,6,0]
print(insert_sort(a))
# 和后面插入排序 外层for循环 过程相同，只是内层的for循环过程不同

print('++++++++++++++++++++++++')
print(bubble_sort(a))
# 冒泡排序 a=[2,4,5,1,6,0] 过程如下: 两两比较，先排出最后一个，再-2个，等等.
# [2, 4, 1, 5, 0, 6]
# [2, 1, 4, 0, 5, 6]
# [1, 2, 0, 4, 5, 6]
# [1, 0, 2, 4, 5, 6]
# [0, 1, 2, 4, 5, 6]


b=[1,2,3,4,5,1,6,0]
b=[2,4,5,1,6,0]

print('===========')
print(insertion_sort(b))
# 插入排序 b=[2,4,5,1,6,0] 过程如下:从第二个开始插入，再第三个 。。。 此前的都是有序的。将后面元素向前面的序列插入
# [2, 4, 5, 1, 6, 0]
# [2, 4, 5, 1, 6, 0]
# [1, 2, 4, 5, 6, 0]
# [1, 2, 4, 5, 6, 0]
# [0, 1, 2, 4, 5, 6]
